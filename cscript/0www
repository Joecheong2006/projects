#include <stdio.h>
#include <string.h>

#include "source_file.h"
#include "string.h"
#include "hashmap.h"
#include "memallocate.h"
#include "lexer.h"
#include "keys_define.h"
#include "util.h"

#define LEXER_ADD_TOKEN(lexer, str_set, type)\
    lexer_add_token((lexer), (token_set){\
                .set_name = str_set,\
                .set_size = sizeof(str_set) / sizeof(void*),\
                .token = type\
            }, type);

void _print_token(token* token, const char* type_name, const char** type_names) {
    printf("(%s, '", type_name);
    for (i32 n = 0; n < token->name_len; ++n) {
        if (token->name[n] == '\n') {
            printf("\\n");
            break;
        }
        putchar(token->name[n]);
    }
    (void)(type_names);
    printf("', %d)\n", token->name_len);
}

void print_token(token* tok) {
    switch (tok->type) {
    case TokenOpenBrace:
    case TokenCloseBrace:
    case TokenOpenSquareBracket:
    case TokenCloseSquareBracket:
    case TokenOpenRoundBracket:
    case TokenCloseRoundBracket:
    case TokenSemicolon:
    case TokenComma:
    case TokenFullStop:
    case TokenNewLine:
                   _print_token(tok, "default separator", NULL); break;
    case TokenKeyword: _print_token(tok, "keyword", Keyword); break;
    case TokenSeparator: _print_token(tok, "separator", Separator); break;
    case TokenOperator: _print_token(tok, "operator", Operator); break;
    case TokenLiteral: _print_token(tok, "literal", NULL); break;
    case TokenStringLiteral: {
        token temp = *tok;
        temp.name += 1;
        temp.name_len -= 2;
        _print_token(&temp, "string literal", NULL);
    } break;
    case TokenIdentifier: _print_token(tok, "identifier", NULL); break;
    case TokenEnd: _print_token(tok, "end", NULL); break;
    case TokenError: _print_token(tok, "error", NULL); break;
    default: _print_token(tok, "unkown", NULL); break;
    }
}

typedef struct {
    void* info;
    string name;
    i32 name_len;
} object;

hashmap object_map;

object* make_object(object* test_data) {
    object* result = MALLOC(sizeof(object));
    memcpy(result, test_data, sizeof(object));
    return result;
}

object* get_object(const char* name) {
    vector(void*) objs = hashmap_access_vector(object_map, &(object){ .name = (string)name });
    for_vector(objs, i, 0) {
        object* obj = objs[i];
        if (strcmp(obj->name, name) == 0) {
            return obj;
        }
    }
    return NULL;
}

size_t hash_object(void* data, size_t size) {
    object* test_data = data;
    // printf("hashing %s\n", test_data->name);
    return djb2(test_data->name) % size;
}

void hashmap_free_test_data(void* data) {
    object* obj = data;
    free_string(&obj->name);
    // NOTE(free obj->info):
    FREE(obj);
}

i32 is_string_literal(token* tok);
void print_token_name(token* tok) {
    i32 n = 0, len = tok->name_len;
    if (is_string_literal(tok)) {
        n = 1;
        len -= 1;
    }

    for (; n < len; ++n) {
        if (tok->name[n] == '\n') {
            printf("\\n");
            break;
        }
        putchar(tok->name[n]);
    }
}

INLINE i32 is_identifier(token* tok) { return tok->type == TokenIdentifier; }
INLINE i32 is_keyword(token* tok, i32 type) { return tok->name_location == type; }
INLINE i32 is_operator(token* tok) { return tok->type == TokenOperator; }
INLINE i32 is_separator(token* tok) { return tok->type == TokenSeparator; }

INLINE i32 is_keyword_type(token* tok, i32 type) { return tok->type == TokenKeyword && tok->name_location == type; }
INLINE i32 is_operator_type(token* tok, i32 type) { return tok->type == TokenOperator && tok->name_location == type; }
INLINE i32 is_separator_type(token* tok, i32 type) { return tok->type == TokenSeparator && tok->name_location == type; }
INLINE i32 is_default_separator_type(token* tok, Token type) { return tok->type == type; }
INLINE i32 is_string_literal(token* tok) { return tok->type == TokenStringLiteral; }

INLINE i32 is_data_type(token* tok) { return tok->type == TokenKeyword && tok->name_location >= KeywordInt && tok->name_location <= KeywordChar; }
INLINE i32 is_assigment_operator(token* tok) { return is_operator(tok) && (tok->name_location >= OperatorAssignementBegin && tok->name_location <= OperatorAssignmentEnd); }

i32 is_real_number(token* tok) { 
    if (is_number(tok->name[0] || (tok->name[0] == '.' && is_number(tok->name[1])))) {
        return 1;
    }

    for (i32 i = 0; i < tok->name_len; ++i)
        if (tok->name[i] == '.')
            return 1;
    return 0;
}

// parser implementation
typedef enum {
    ParseErrorNoError,
    ParseErrorMissingToken,
    ParseErrorMissingRhs,
} ParseError;

typedef struct {
    vector(token) tokens;
    u64 index, tokens_len;
    ParseError error;
} parser;

INLINE void set_parse_error(parser* par, i32 error) {
    if (par->error != ParseErrorNoError)
        return;
    par->error = error;
}

INLINE token* parser_peek(parser* par, i32 location) {
    return par->tokens + par->index + location;
}

INLINE token* parser_peekpre(parser* par, i32 location) {
    return par->tokens + par->tokens_len + location;
}

u64 cal_line_stride(const  char* buffer, i32 line_count) {
    u64 first_n = 0;

    for (i32 i = 0; i < line_count; ++i) {
        first_n = strchr(buffer + first_n, '\n') - buffer + 1;
    }
    return first_n;
}
// decent parsing implementation
typedef enum {
    NodeVariable,
    NodeVariableAssign,
    NodeOperator,
    NodeOperatoAssignment,
    NodeNumber,
} NodeType;


typedef struct tree_node tree_node;
struct tree_node {
    NodeType type;
    i32 object_type;
    const char* name;
    i32 name_len;
    void* info;
    vector(tree_node*) nodes;
};

tree_node* make_tree_node(NodeType type, i32 object_type, const char* name, i32 name_len) {
    tree_node* node = MALLOC(sizeof(tree_node));
    memcpy(node, &(tree_node) {
        .type = type,
        .object_type = object_type,
        .name = name,
        .name_len = name_len,
        .nodes = make_vector(),
        .info = NULL
    }, sizeof(tree_node));
    return node;
}

void free_node(tree_node* node) {
    free_vector(&node->nodes);
    FREE(node);
}

void print_node(tree_node* node) {
    printf("node ");
    switch (node->type) {
    case NodeVariable: printf("variable"); break;
    case NodeOperator: printf("operator"); break;
    case NodeNumber: printf("number"); break;
    default: break;
    }
    putchar(' ');
    print_token_name(&(token) {
                .name = node->name,
                .name_len = node->name_len,
            });
    printf(" %d\n", node->object_type);
}

void bfs(tree_node* root, void(*take_action)(tree_node*)) {
    take_action(root);
    for_vector(root->nodes, i, 0) {
        bfs(root->nodes[i], take_action);
    }
}

void dfs(tree_node* root, void(*take_action)(tree_node*)) {
    for_vector(root->nodes, i, 0) {
        dfs(root->nodes[i], take_action);
    }
    take_action(root);
}

void free_tree(tree_node* node) {
    free_node(node);
}

// a = 1 + 3

tree_node* try_parse_identifier(parser* par) {
    token* tok = parser_peek(par, 0);
    return make_tree_node(NodeVariable, tok->name_location, tok->name, tok->name_len);
}

tree_node* try_parse_number(parser* par) {
    token* tok = parser_peek(par, 0);
    if (is_real_number(tok)) {
        return make_tree_node(NodeNumber, KeywordFloat, tok->name, tok->name_len);
    }
    if (is_number(tok->name[0])) {
        return make_tree_node(NodeNumber, KeywordInt, tok->name, tok->name_len);
    }
    return NULL;
}

tree_node* try_parse_operator(parser* par) {
    token* tok = parser_peek(par, 0);
    return make_tree_node(NodeOperator, tok->name_location, tok->name, tok->name_len);
}

tree_node* try_parse_expression(parser* par);

tree_node* try_parse_round_bracket_pair(parser* par) {
    tree_node* expr = try_parse_expression(par);
    if (!expr) {
        return NULL;
    }
    return expr;
}

tree_node* try_parse_expression(parser* par) {
    tree_node* lhs = NULL;
    i32 has_bracket = 0;

    if (is_identifier(parser_peek(par, 0))) {
        lhs = try_parse_identifier(par);
    }
    else if (is_default_separator_type(parser_peek(par, 0), TokenOpenRoundBracket)) {
        ++par->index;
        has_bracket = 1;
        lhs = try_parse_round_bracket_pair(par);
    }
    else if (is_number(parser_peek(par, 0)->name[0]) || is_real_number(parser_peek(par, 0))) {
        lhs = try_parse_number(par);
    }
    else {
        return NULL;
    }

    ++par->index;
    tree_node* operator = NULL;

    if (is_default_separator_type(parser_peek(par, 0), TokenCloseRoundBracket) ||
        parser_peek(par, 0)->type == TokenNewLine || 
        par->index == par->tokens_len) {
        return lhs;
    }

    if (is_operator(parser_peek(par, 0))) {
        operator = try_parse_operator(par);
    }

    if (!operator) {
        free_node(lhs);
        set_parse_error(par, ParseErrorMissingToken);
        return NULL;
    }

    vector_pushe(operator->nodes, lhs);
    ++par->index;
    tree_node* rhs = try_parse_expression(par);
    if (!rhs) {
        set_parse_error(par, ParseErrorMissingRhs);
        free_node(lhs);
        free_node(operator);
        return NULL;
    }

    if (has_bracket && vector_size(rhs->nodes) > 0 && operator->object_type > rhs->object_type) {
        vector_pushe(operator->nodes, rhs->nodes[0]);
        rhs->nodes[0] = operator;
        return rhs;
    }
    else {
        vector_pushe(operator->nodes, rhs);
        return operator;
    }
}

tree_node* try_parse_variable(parser* par) {
    token* var_tok = parser_peek(par, 0);
    tree_node* var = make_tree_node(NodeVariable, -1, var_tok->name, var_tok->name_len);
    if (is_assigment_operator(parser_peek(par, 1))) {
        token* assign_tok = parser_peek(par, 1);
        tree_node* assign_operator = make_tree_node(NodeOperator, assign_tok->name_location, assign_tok->name, assign_tok->name_len);
        par->index += 2;
        tree_node* expression = try_parse_expression(par);
        if (!expression) {
            free_node(var);
            free_node(assign_operator);
            return NULL;
        }
        vector_pushe(var->nodes, assign_operator);
        vector_pushe(var->nodes[0]->nodes, expression);
    }
    return var;
}

tree_node* parser_parse(parser* par) {
    switch (par->tokens[0].type) {
    case TokenIdentifier: {
        return try_parse_variable(par);
    } break;
    default:
        break;
    }
    return NULL;
}

void command_line_mode(lexer* lexer) {
    u64 line_count = 0, max_line_count = 0;
    u64 begin = 0, end = 0;
    vector(token) tokens = NULL;

    string source_buffer = make_string("");

    while(1) {
        char input[100];
        printf(">");
        fgets(input, sizeof(input), stdin);
        if (input[0] != '.') {
            string_push(source_buffer, input);
            max_line_count++;
            continue;
        }

        if (strlen(input) <= 1) {
            continue;
        }

        switch (input[1]) {
        case 'q': {
            if (tokens) free_vector(&tokens);
            free_string(&source_buffer);
            return;
        }
        case 'b': {
            for (u64 i = 1; i <= max_line_count; ++i) {
                printf("%s", i == line_count ? " -> " : "    ");
                for (u64 j = cal_line_stride(source_buffer, i - 1);
                         j < cal_line_stride(source_buffer, i); ++j) {
                    putchar(source_buffer[j]);
                }
            }
        } break;
        case 'p': {
            if (tokens) {
                parser par = { .index = 0, .tokens = tokens, .tokens_len = vector_size(tokens), .error = ParseErrorNoError };
                tree_node* node = parser_parse(&par);
                if (node) {
                    bfs(node, print_node);
                    dfs(node, free_tree);
                }
                printf("error %d\n", par.error);
            }
        } break;
        case 'n': {
            begin = cal_line_stride(source_buffer, line_count);
            end = cal_line_stride(source_buffer, line_count + 1);

            ++line_count;
            if (line_count > max_line_count) {
                --line_count;
                printf("no next line\n");
                break;
            }

            if (tokens) free_vector(&tokens);

            tokens = lexer_tokenize_until(lexer, source_buffer + begin, '\n');

            i32 len = end - begin;
            printf("<line:%llu> ", line_count);
            for (i32 c = 0; c < len; ++c) {
                putchar((source_buffer + begin)[c]);
            }
            putchar('\n');
        } break;
        case 'j': {
            if (is_number(input[2])) {
                u64 line = atoi(&input[2]);
                if (line > max_line_count) {
                    printf("out of line\n");
                    break;
                }
                line_count = line;
                if (tokens) free_vector(&tokens);
                begin = cal_line_stride(source_buffer, line_count - 1);
                end = cal_line_stride(source_buffer, line_count);
                tokens = lexer_tokenize_until(lexer, source_buffer + begin, '\n');
            }
        } break;
        default: break;
        }
    }
    if (tokens) free_vector(&tokens);
    free_string(&source_buffer);
    CHECK_MEMORY_LEAK();
}

void* interpret(tree_node* instruction);
void interpret_node_variable(tree_node* node) {
    (void)node;
    interpret(node->nodes[0]);
}

int get_node_number_value_int(tree_node* node) {
    return atoi(node->name);
}

float get_node_number_value_float(tree_node* node) {
    return atof(node->name);
}

tree_node* interpret_operator_plus(void* out, KeywordType data_type, tree_node* lhs, tree_node* rhs) {
    (void)lhs, (void)rhs, (void)data_type;
    tree_node* result = make_tree_node(NodeNumber, data_type, "", -1);
    switch (data_type) {
    case KeywordInt: {
        int lhs_value = get_node_number_value_int(lhs);
        int rhs_value = get_node_number_value_int(rhs);
        int sum = lhs_value + rhs_value;
        printf("%d %d\n", lhs_value, rhs_value);
        memcpy(out, &sum, sizeof(int));
    }break;
    case KeywordFloat: {
    } break;
    default: break;
    }
    return result;
}

tree_node* interpret_operator_minus(KeywordType data_type, tree_node* lhs, tree_node* rhs) {
    (void)lhs, (void)rhs, (void)data_type;
    tree_node* result = NULL;
    return result;
}

tree_node* interpret_operator_multiply(KeywordType data_type, tree_node* lhs, tree_node* rhs) {
    (void)lhs, (void)rhs, (void)data_type;
    tree_node* result = NULL;
    return result;
}

tree_node* interpret_operator_division(KeywordType data_type, tree_node* lhs, tree_node* rhs) {
    (void)lhs, (void)rhs, (void)data_type;
    tree_node* result = NULL;
    return result;
}

tree_node* interpret_operator_arithmetic(void* out, KeywordType data_type, OperatorType type, tree_node* lhs, tree_node* rhs) {
    switch (type) {
    case OperatorPlus: return interpret_operator_plus(out, data_type, lhs, rhs); break;
    case OperatorMinus: return interpret_operator_minus(data_type, lhs, rhs); break;
    case OperatorMultiply: return interpret_operator_multiply(data_type, lhs, rhs); break;
    case OperatorDivision: return interpret_operator_division(data_type, lhs, rhs); break;
    default: break;
    }
    return NULL;
}

void get_expression_data_type(KeywordType* out, tree_node* expression) {
    for_vector(expression->nodes, i, 0) {
        get_expression_data_type(out, expression->nodes[i]);
    }
    if (expression->type == NodeNumber && expression->object_type > (i32)*out) {
        *out = expression->object_type;
    }
}

tree_node* interpret_cal_expression(void* out, KeywordType data_type, tree_node* node) {
    switch (node->type) {
    case NodeOperator: {
        tree_node* lhs = interpret_cal_expression(out, data_type, node->nodes[0]);
        tree_node* rhs = interpret_cal_expression(out, data_type, node->nodes[1]);
        tree_node* result = interpret_operator_arithmetic(out, data_type, node->object_type, lhs, rhs);
        return result;
    } break; 
    case NodeNumber: return node;
    default: break;
    }
    return NULL;
}

void interpret_node_operator_assignment(tree_node* node) {
    (void)node;
}

void* interpret(tree_node* instruction) {
    switch (instruction->type) {
    case NodeVariableAssign: break;
    case NodeOperator: break;
    case NodeOperatoAssignment: break;
    case NodeNumber: break;
    default: break;
    };
    return NULL;
}

i32 main(i32 argc, char** argv) {
    object_map = make_hashmap(1 << 10, hash_object);

    lexer lexer;

    LEXER_ADD_TOKEN(&lexer, Keyword, TokenKeyword);
    LEXER_ADD_TOKEN(&lexer, Separator, TokenSeparator);
    LEXER_ADD_TOKEN(&lexer, Operator, TokenOperator);
    LEXER_ADD_TOKEN(&lexer, StringBegin, TokenStringBegin);
    
#if 1
    // {
    //     char text[] = "...>>:=(1[2{3}2]1)0xabcdef(1)\n";
    //     vector(token) tokens = lexer_tokenize_test(&lexer, text, '\n');
    //     for_vector(tokens, i, 0) {
    //         print_token(tokens + i);
    //     }
    //     free_vector(&tokens);
    //     return 0;
    // }
    {
        /*          val
         *           |
         *           =
         *           |
         *           -
         *          / \
         *         *   3
         *        / \
         *      1.2  2
         *
         */
        const char text[] = "val=3+3+4\n";
        vector(token) tokens = lexer_tokenize_until(&lexer, text, '\n');

        for_vector(tokens, i, 0) {
            print_token_name(tokens + i);
            putchar(' ');
        }
        putchar('\n');

        parser par = {
            .index = 0,
            .tokens = tokens,
            .tokens_len = vector_size(tokens),
            .error = ParseErrorNoError,
        };
        tree_node* node = parser_parse(&par);
        if (node) {
            bfs(node, print_node);

            KeywordType type = 0;
            get_expression_data_type(&type, node->nodes[0]->nodes[0]);
            void* expr_result = MALLOC(sizeof(int));
            interpret_cal_expression(expr_result, type, node->nodes[0]->nodes[0]);

            switch (type) {
            case KeywordInt: printf("expression %d\n", *(int*)expr_result); break;
            case KeywordFloat: printf("expression %g\n", *(float*)expr_result); break;
            default: break;
            }
            FREE(expr_result);

            printf("%d\n", type);

            dfs(node, free_tree);
        }
        printf("error %d\n", par.error);

        free_vector(&tokens);
        hashmap_free_items(object_map, hashmap_free_test_data);
        free_hashmap(&object_map);
        CHECK_MEMORY_LEAK();
        return 0;
    }
#endif

    if (argc == 1) {
        command_line_mode(&lexer);
        exit(0);
    }

    // TODO: to pack source file
    source_file source;
    i32 success = load_source(&source, argv[1]);

    if (!success) {
        printf("failed load source\n");
        exit(1);
    }

    printf("size = %llu, line count = %llu\n", source.buffer_size, source.line_count);
    printf("----- source begin ------\n%s----- source end -----\n\n", source.buffer);

    u64 offset = 0;
    u64 first_n = 0;
    for (u64 i = 0; i < source.line_count; ++i) {
        first_n = strchr(source.buffer + offset, '\n') - source.buffer - offset + 1;

        // vector(token) tokens = lexer_tokenize_until(&lexer, source.buffer + offset, '\n');
        vector(token) tokens = lexer_tokenize_until(&lexer, source.buffer + offset, '\n');

        // try match pattern else it's a error
        printf("<line:%llu> ", i + 1);
        for (u64 c = 0; c < first_n; ++c) {
            putchar((source.buffer + offset)[c]);
        }
        for_vector(tokens, i, 0) {
            print_token(tokens + i);
        }

        // parser_test(tokens);
        putchar('\n');

        free_vector(&tokens);
        offset += first_n;
    }

    vector(void*) result = hashmap_access_vector(object_map, &(object){
                    .name = "number"
                });

    for_vector(result, i, 0) {
        object* item = result[i];
        print_token(&(token){
                    .name = item->name,
                    .name_len = item->name_len,
                    .type = TokenIdentifier,
                });
    }

    hashmap_free_items(object_map, hashmap_free_test_data);
    free_hashmap(&object_map);
    free_source(&source);
    CHECK_MEMORY_LEAK();
}

